import logging
from datetime import datetime
from typing import NoReturn, List, Tuple, Optional

import monobank
from aiogram import Bot
from aiogram.exceptions import TelegramAPIError

logger = logging.getLogger("monobank")


class MonobankService:
    def __init__(self, token: str):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∫–ª–∞—Å—É MonobankService."""

        self.token = token
        self.client = monobank.Client(token=token)

    def setup_webhook(self, webhook_url: str) -> NoReturn:
        """–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≤–µ–±—Ö—É–∫–∞ Monobank."""
        try:
            client_info = self.client.get_client_info()
            if not client_info.get("webHookUrl"):
                self.client.create_webhook(url=webhook_url)
                logger.info("Webhook successfully created")
            else:
                logger.info("Webhook is already configured")
        except monobank.TooManyRequests as e:
            logger.error("Rate limit exceeded: %s. Retrying later...", e)
        except monobank.Error as e:
            logger.error("API error occurred: %s", e)

    def get_credit_card_ids(self) -> List[Tuple[str, str]]:
        """–û—Ç—Ä–∏–º—É—î —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–∏ –∫—Ä–µ–¥–∏—Ç–Ω–∏—Ö —Ä–∞—Ö—É–Ω–∫—ñ–≤ —Ç–∞ —ó—Ö –¥–µ—Ç–∞–ª—ñ."""
        try:
            accounts = self.client.get_client_info().get("accounts", [])
        except monobank.Error as e:
            logger.error("Error occurred: %s", e)
            return []

        card_choices = []
        for account in accounts:
            account_id = account.get("id", "Unknown ID")
            account_type = account.get("type", "Unknown type")
            masked_pan = account.get("maskedPan", ["Unknown maskedPan"])

            card_choices.append(
                (account_id, f"{account_type} - {', '.join(masked_pan)}")
            )

        return card_choices

    def is_token_valid(self) -> bool:
        """–ü–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ –¥—ñ–π—Å–Ω–∏–π —Ç–æ–∫–µ–Ω."""
        try:
            self.client.get_client_info()
            return True
        except monobank.Error:
            return False


class TransactionDataParser:
    """–ö–ª–∞—Å –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–∞ –ø–∞—Ä—Å–∏–Ω–≥—É –¥–∞–Ω–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó."""

    def __init__(self, data: dict):
        self._data = data
        self._statement_item = data["statementItem"]

    @property
    def amount(self) -> float:
        return self._statement_item["amount"] / 100

    @property
    def balance(self) -> float:
        return self._statement_item["balance"] / 100

    @property
    def description(self) -> str:
        return self._statement_item.get("description", "–ù–µ –∑–∞–∑–Ω–∞—á–µ–Ω–æ")

    @property
    def comment(self) -> str:
        return self._statement_item.get("comment", "---")

    @property
    def receipt_id(self) -> str:
        return self._statement_item.get("receiptId", "")

    @property
    def timestamp(self) -> int:
        return self._statement_item["time"]


class DateTimeFormatter:
    """–ö–ª–∞—Å –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –¥–∞—Ç–∏ —Ç–∞ —á–∞—Å—É"""

    def __init__(self, timestamp: int):
        self._date_time = datetime.fromtimestamp(timestamp)

    @property
    def formatted_date(self) -> str:
        return self._date_time.strftime("%d %B %Y —Ä.")

    @property
    def formatted_time(self) -> str:
        return self._date_time.strftime("%H:%M:%S")


class MessageTemplate:
    """–ë–∞–∑–æ–≤–∏–π –∫–ª–∞—Å –¥–ª—è —à–∞–±–ª–æ–Ω—ñ–≤ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""

    def __init__(
        self, parser: TransactionDataParser, dt_formatter: DateTimeFormatter
    ):
        self.parser = parser
        self.dt_formatter = dt_formatter

    @property
    def common_part(self) -> str:
        return (
            f"üí¨ {self.parser.comment}\n"
            f"üí∞ –°—É–º–∞: {self.parser.amount:.2f}\n"
            f"üíµ –ë–∞–ª–∞–Ω—Å: {self.parser.balance:.2f}\n"
            "„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞„Ä∞"
        )


class IncomeMessageTemplate(MessageTemplate):
    """–®–∞–±–ª–æ–Ω –¥–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –Ω–∞–¥—Ö–æ–¥–∂–µ–Ω–Ω—è"""

    @property
    def message(self) -> str:
        return (
            "‚úÖ –ó–∞—Ä–∞–∑ –≤—ñ–¥–±—É–ª–æ—Å—å –Ω–∞–¥—Ö–æ–¥–∂–µ–Ω–Ω—è!\n\n"
            f"üìÖ {self.dt_formatter.formatted_date} üïò {self.dt_formatter.formatted_time}\n"
            f"üí≥ {self.parser.description}\n"
            f"{self.common_part}"
        )


class ExpenseMessageTemplate(MessageTemplate):
    """–®–∞–±–ª–æ–Ω –¥–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –≤–∏—Ç—Ä–∞—Ç—É"""

    @property
    def message(self) -> str:
        return (
            "üîª –©–æ–π–Ω–æ –±—É–ª–∏ –≤–∏—Ç—Ä–∞—á–µ–Ω—ñ –∫–æ—à—Ç–∏!\n\n"
            f"üìÖ {self.dt_formatter.formatted_date} üïò {self.dt_formatter.formatted_time}\n"
            f"üõç –ö–æ–º—É: {self.parser.description}\n"
            f"üßæ <a href='https://check.gov.ua/'>{self.parser.receipt_id}</a>\n"
            f"{self.common_part}"
        )


class MonoBankMessageFormatter:
    """–ì–æ–ª–æ–≤–Ω–∏–π –∫–ª–∞—Å –¥–ª—è —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""

    def __init__(self, data: dict):
        self.parser = TransactionDataParser(data)
        self.dt_formatter = DateTimeFormatter(self.parser.timestamp)

    def format_message(self) -> str:
        if self.parser.amount > 0:
            template = IncomeMessageTemplate(self.parser, self.dt_formatter)
        else:
            template = ExpenseMessageTemplate(self.parser, self.dt_formatter)
        return template.message


class MonoBankChatIDProvider:
    """–ö–ª–∞—Å –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è chat_id –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö"""

    def __init__(self, account: str, db_model, admins: list):
        self.account = account
        self.db_model = db_model
        self.admins = admins

    def get_chat_ids(self) -> Optional[List[int]]:
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä—ñ–≤ —á–∞—Ç—ñ–≤"""
        try:
            chat_id = self.db_model.objects.get(card_id=self.account).chat_id
            return [chat_id] if chat_id else self.admins
        except self.db_model.DoesNotExist:
            return None


class TelegramMessageSender:
    """–ö–ª–∞—Å –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –≤ Telegram"""

    def __init__(self, bot: Bot):
        self.bot = bot

    async def send_message(
        self, message: str, chat_ids: List[int] | None
    ) -> bool:
        """
        –í—ñ–¥–ø—Ä–∞–≤–ª—è—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –∑–∞–∑–Ω–∞—á–µ–Ω—ñ —á–∞—Ç–∏
        –ü–æ–≤–µ—Ä—Ç–∞—î —Å—Ç–∞—Ç—É—Å –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è (True/False)
        """
        if not chat_ids:
            return False

        success = False
        for chat_id in chat_ids:
            try:
                await self.bot.send_message(
                    chat_id=chat_id,
                    text=message,
                    parse_mode="HTML",
                    disable_web_page_preview=True,
                )
                success = True
            except TelegramAPIError as e:
                logger.error(
                    "–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è %s: %s", chat_id, e
                )

        return success


if __name__ == "__main__":
    pass
